//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "types.go", nil, parser.AllErrors)
	if err != nil {
		panic(err)
	}

	var allTYpes, typeCaster strings.Builder
	allTYpes.WriteString("// Code generated by gen_types.go DO NOT EDIT.\n")
	allTYpes.WriteString("package types\n\n")
	allTYpes.WriteString("import \"github.com/nagarajRPoojari/orange/internal/errors\"\n\n")
	allTYpes.WriteString("var AllTypes = map[string]struct{}{\n")

	typeCaster.WriteString("func TypeCast(castTo string, val interface{}) (interface{}, error) { \n")
	typeCaster.WriteString("switch castTo { \n")

	for i, decl := range node.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok.String() != "type" {
			continue
		}
		for _, spec := range gen.Specs {
			tspec := spec.(*ast.TypeSpec)
			if tspec.Name.IsExported() {
				if i == len(node.Decls)-1 {
					allTYpes.WriteString("\t\"" + tspec.Name.Name + "\": {},\n")
				} else {

					allTYpes.WriteString("\t\"" + tspec.Name.Name + "\": {},\n")
				}
				typeCaster.WriteString(" \t case \"" + tspec.Name.Name + "\": \n")
				typeCaster.WriteString(fmt.Sprintf("\t \t return To%s(val) \n", tspec.Name.Name))

			}
		}
	}
	typeCaster.WriteString("\t}\n")
	typeCaster.WriteString("return nil, errors.TypeCastError(\"type not found\")\n")
	typeCaster.WriteString("}")
	allTYpes.WriteString("}\n")

	err = os.WriteFile("generated_types.go", []byte(allTYpes.String()+typeCaster.String()), 0644)
	if err != nil {
		panic(err)
	}
}
